<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tatce Chatbot</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<h1 class="chat-title">TATCE Chatbot</h1>

<div id="chat-container">
  </div>  

  <div id="input-container">
    <!-- Example prompts now appear first in the column layout -->
    <div id="example-prompts">
        <button class="example-button">Kdy bude nejbližší zber odpadu?</button>
        <button class="example-button">Jaké jsou aktuální novinky v obci?</button>
        <button class="example-button">Aktuality z minulého měsíce.</button>
        <button class="example-button">Jaké kulturní akce se plánují tento měsíc?</button>
    </div>
    
    <!-- Input and send button now in a row below the example buttons -->
    <div class="input-row">
        <textarea id="user-input" placeholder="Type your message..."></textarea>
        <button id="send-button">Send</button>
    </div>
</div>

<script>
  const chatContainer = document.getElementById('chat-container');
  const userInput = document.getElementById('user-input');
  const sendButton = document.getElementById('send-button');

  function appendMessage(message, sender) {
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message', `${sender}-message`);
    // Convert markdown to HTML
    const html = marked.parse(message);
    messageDiv.innerHTML = html;
    chatContainer.appendChild(messageDiv);
    setTimeout(() => {
      chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    }, 0); // Scroll to bottom after DOM update
  }

  async function getBotResponse(userMessage, onChunk) {
    try {
      const response = await fetch('api.php', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ prompt: userMessage })
      });

      if (!response.ok || !response.body) {
        onChunk('Error: API request failed');
        return;
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder('utf-8');
      let fullText = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        fullText += chunk;

        // Process SSE lines
        const lines = chunk.split('\n');
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const dataStr = line.replace('data: ', '').trim();
            if (dataStr === '[DONE]') continue;
            try {
              const dataObj = JSON.parse(dataStr);
              const delta = dataObj.choices?.[0]?.delta?.content;
              if (delta) {
                onChunk(delta);
              }
            } catch (e) {
              console.error('Error parsing chunk JSON', e);
            }
          }
        }
      }
    } catch (error) {
      onChunk('Error: ' + error.message);
    }
  }

  sendButton.addEventListener('click', () => {
    const message = userInput.value;
    if (message.trim() !== '') {
      appendMessage(message, 'user');
      userInput.value = '';
      userInput.style.height = '40px';

      // Create bot message element immediately
      const botMessageElem = document.createElement('div');
      botMessageElem.classList.add('message', 'bot-message');
      botMessageElem.innerHTML = '';
      chatContainer.appendChild(botMessageElem);

      // Scroll to bottom
      setTimeout(() => {
        chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
        window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
      }, 0);

      // Buffer for full streamed response
      let fullResponse = '';

      // Stream bot response
      getBotResponse(message, (chunk) => {
        fullResponse += chunk;
        botMessageElem.innerHTML = marked.parse(fullResponse);
        // Optional: scroll as new text arrives
        chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
      });
    }
  });

  userInput.addEventListener('keypress', (event) => {
    if (event.key === 'Enter') {
      sendButton.click();
    }
  });
  // Auto-resize textarea
  userInput.addEventListener('input', () => {
    userInput.style.height = 'auto';
    userInput.style.height = userInput.scrollHeight + 'px';

    const examplePrompts = document.getElementById('example-prompts');
    if (userInput.value.trim() !== '') {
      examplePrompts.style.display = 'none';
    } else {
      examplePrompts.style.display = 'grid';
    }
  });
  // Add event listeners to example prompt buttons
  document.querySelectorAll('.example-button').forEach(button => {
    button.addEventListener('click', () => {
      const exampleText = button.textContent;
      userInput.value = exampleText;
      sendButton.click();
    });
  });
</script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

</body>
</html>